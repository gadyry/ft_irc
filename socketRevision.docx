1 - What is socket ?
=> create socket :
    socket -- create an endpoint for communication

SYNOPSIS
     #include <sys/socket.h>

     int
     socket(int domain, int type, int protocol);

DESCRIPTION
     socket() creates an endpoint for communication and returns a descriptor.

     The domain parameter specifies a communications domain within which communication will take place; this selects the protocol family
     which should be used.  These families are defined in the include file <sys/socket.h>.  The currently understood formats are

           PF_LOCAL        Host-internal protocols, formerly called PF_UNIX,
           PF_UNIX         Host-internal protocols, deprecated, use PF_LOCAL,
           PF_INET         Internet version 4 protocols,
           PF_ROUTE        Internal Routing protocol,
           PF_KEY          Internal key-management function,
           PF_INET6        Internet version 6 protocols,
           PF_SYSTEM       System domain,
           PF_NDRV         Raw access to network device

     The socket has the indicated type, which specifies the semantics of communication.  Currently defined types are:

           SOCK_STREAM
           SOCK_DGRAM
           SOCK_RAW

     A SOCK_STREAM type provides sequenced, reliable, two-way connection based byte streams.  An out-of-band data transmission mechanism may
     be supported.  A SOCK_DGRAM socket supports datagrams (connectionless, unreliable messages of a fixed (typically small) maximum length).
     SOCK_RAW sockets provide access to internal network protocols and interfaces.  The type SOCK_RAW, which is available only to the super-user

     The protocol specifies a particular protocol to be used with the socket.  Normally only a single protocol exists to support a particular
     socket type within a given protocol family.  However, it is possible that many protocols may exist, in which case a particular protocol
     must be specified in this manner.  The protocol number to use is particular to the communication domain in which communication is to
     take place; see protocols(5).

     Sockets of type SOCK_STREAM are full-duplex byte streams, similar to pipes.  A stream socket must be in a connected state before any
     data may be sent or received on it.  A connection to another socket is created with a connect(2) or connectx(2) call.  Once connected,
     data may be transferred using read(2) and write(2) calls or some variant of the send(2) and recv(2) calls.  When a session has been com-
     pleted a close(2) may be performed.  Out-of-band data may also be transmitted as described in send(2) and received as described in
     recv(2).

     The communications protocols used to implement a SOCK_STREAM insure that data is not lost or duplicated.  If a piece of data for which
     the peer protocol has buffer space cannot be successfully transmitted within a reasonable length of time, then the connection is consid-
     ered broken and calls will indicate an error with -1 returns and with ETIMEDOUT as the specific code in the global variable errno.  The
     protocols optionally keep sockets ``warm'' by forcing transmissions roughly every minute in the absence of other activity.  An error is
     then indicated if no response can be elicited on an otherwise idle connection for a extended period (e.g. 5 minutes).  A SIGPIPE signal
     is raised if a process sends on a broken stream; this causes naive processes, which do not handle the signal, to exit.

     SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in send(2) calls.  Datagrams are generally received
     with recvfrom(2), which returns the next datagram with its return address.

     An fcntl(2) call can be used to specify a process group to receive a SIGURG signal when the out-of-band data arrives.  It may also
     enable non-blocking I/O and asynchronous notification of I/O events via SIGIO.

     The operation of sockets is controlled by socket level options.  These options are defined in the file <sys/socket.h>.  Setsockopt(2)
     and getsockopt(2) are used to set and get options, respectively.

RETURN VALUES
     A -1 is returned if an error occurs, otherwise the return value is a descriptor referencing the socket.

ERRORS
     The socket() system call fails if:

     [EACCES]           Permission to create a socket of the specified type and/or protocol is denied.
    
     [EAFNOSUPPORT]     The specified address family is not supported.

     [EMFILE]           The per-process descriptor table is full.

     [ENFILE]           The system file table is full.

     [ENOBUFS]          Insufficient buffer space is available.  The socket cannot be created until sufficient resources are freed.

     [ENOMEM]           Insufficient memory was available to fulfill the request.

     [EPROTONOSUPPORT]  The protocol type or the specified protocol is not supported within this domain.

     [EPROTOTYPE]       The socket type is not supported by the protocol.

     If a new protocol family is defined, the socreate process is free to return any desired error code.  The socket() system call will pass
     this error code along (even if it is undefined).

LEGACY SYNOPSIS
     #include <sys/types.h>
     #include <sys/socket.h>

     The include file <sys/types.h> is necessary.

2 - Bind a socket;

    NAME
     bind -- bind a name to a socket

SYNOPSIS
     #include <sys/socket.h>

     int
     bind(int socket, const struct sockaddr *address, socklen_t address_len);

DESCRIPTION
     bind() assigns a name to an unnamed socket.  When a socket is created with socket(2) it exists in a name space (address family) but has
     no name assigned.  bind() requests that address be assigned to the socket.

NOTES
     Binding a name in the UNIX domain creates a socket in the file system that must be deleted by the caller when it is no longer needed
     (using unlink(2)).

     The rules used in name binding vary between communication domains.  Consult the manual entries in section 4 for detailed information.

RETURN VALUES
     Upon successful completion, a value of 0 is returned.  Otherwise, a value of -1 is returned and the global integer variable errno is set
     to indicate the error.

ERRORS
     The bind() system call will fail if:

     [EACCES]           The requested address is protected, and the current user has inadequate permission to access it.

     [EADDRINUSE]       The specified address is already in use.

     [EADDRNOTAVAIL]    The specified address is not available from the local machine.

     [EAFNOSUPPORT]     address is not valid for the address family of socket.

          [EBADF]            socket is not a valid file descriptor.

     [EDESTADDRREQ]     socket is a null pointer.

     [EFAULT]           The address parameter is not in a valid part of the user address space.

     [EINVAL]           socket is already bound to an address and the protocol does not support binding to a new address.  Alternatively,
                        socket may have been shut down.

     [ENOTSOCK]         socket does not refer to a socket.

     [EOPNOTSUPP]       socket is not of a type that can be bound to an address.

     The following errors are specific to binding names in the UNIX domain.

     [EACCES]           A component of the path prefix does not allow searching or the node's parent directory denies write permission.

     [EEXIST]           A file already exists at the pathname.  unlink(2) it first.

     [EIO]              An I/O error occurred while making the directory entry or allocating the inode.

     [EISDIR]           An empty pathname was specified.

     [ELOOP]            Too many symbolic links were encountered in translating the pathname.  This is taken to be indicative of a looping
                        symbolic link.

     [ENAMETOOLONG]     A component of a pathname exceeded {NAME_MAX} characters, or an entire path name exceeded {PATH_MAX} characters.

     [ENOENT]           A component of the path name does not refer to an existing file.

     [ENOTDIR]          A component of the path prefix is not a directory.

     [EROFS]            The name would reside on a read-only file system.

    LEGACY SYNOPSIS
     #include <sys/types.h>
     #include <sys/socket.h>

